import { CompilerOptions } from '@vue/compiler-dom';
import { RenderFunction } from '@vue/runtime-dom';

export function use(Router: {RouteParams: RouteParams; RouteRecordRedirectOption: RouteRecordRedirectOption; _RouteRecordBase: _RouteRecordBase; RouteLocationPathRaw: RouteLocationPathRaw; RouteRecordName: RouteRecordName; useRouter(): Router; RouteRecord: RouteRecord; parseQuery(search: string): LocationQuery; RouterHistory: RouterHistory; LocationQuery: LocationQuery; NavigationGuard: NavigationGuard; RouterLinkProps: RouterLinkProps; RouteLocationRaw: RouteLocationRaw; routeLocationKey: InjectionKey<RouteLocationNormalizedLoaded>; NavigationFailure: NavigationFailure; isNavigationFailure: {(error: any, type?: ErrorTypes.NAVIGATION_GUARD_REDIRECT): error is NavigationRedirectError; (error: any, type?: (ErrorTypes | NavigationFailureType)): error is NavigationFailure}; HistoryState: HistoryState; createWebHashHistory(base?: string): RouterHistory; routerKey: InjectionKey<Router>; RouteParamValue: RouteParamValue; RouterOptions: RouterOptions; RouteComponent: RouteComponent; NavigationHookAfter: NavigationHookAfter; ErrorTypes: ErrorTypes; createWebHistory(base?: string): RouterHistory; NavigationGuardWithThis: NavigationGuardWithThis; routerViewLocationKey: InjectionKey<Ref<RouteLocationNormalizedLoaded>>; Router: Router; loadRouteLocation(route: RouteLocationNormalized): Promise<RouteLocationNormalizedLoaded>; createMemoryHistory(base?: string): RouterHistory; onBeforeRouteUpdate(updateGuard: NavigationGuard): void; NavigationRedirectError: NavigationRedirectError; _RouteLocationBase: _RouteLocationBase; viewDepthKey: InjectionKey<number | Ref<number>>; RouteRecordNormalized: RouteRecordNormalized; LocationQueryValueRaw: LocationQueryValueRaw; RouteLocationNormalizedLoaded: RouteLocationNormalizedLoaded; TypesConfig: TypesConfig; LocationQueryRaw: LocationQueryRaw; LocationQueryValue: LocationQueryValue; RouteLocationMatched: RouteLocationMatched; onBeforeRouteLeave(leaveGuard: NavigationGuard): void; RouteParamValueRaw: RouteParamValueRaw; RouteLocationNormalized: RouteLocationNormalized; stringifyQuery(query: LocationQueryRaw): string; RouteLocation: RouteLocation; RouterLink: _RouterLinkI; RouteLocationNamedRaw: RouteLocationNamedRaw; RouteParamsRaw: RouteParamsRaw; PathParserOptions: PathParserOptions; _RouterLinkI: _RouterLinkI; MatcherLocationAsPath: MatcherLocationAsPath; useRoute(): RouteLocationNormalizedLoaded; _PathParserOptions: _PathParserOptions; RouteRecordRaw: RouteRecordRaw; NavigationGuardNext: NavigationGuardNext; RouteQueryAndHash: RouteQueryAndHash; RouteMeta: RouteMeta; RouterView: {new(): {$props: AllowedComponentProps & ComponentCustomProps & VNodeProps & RouterViewProps; $slots: {default: (arg: {Component: VNode; route: RouteLocationNormalizedLoaded}) => VNode[]}}}; RouterScrollBehavior: RouterScrollBehavior; useLink(props: UseLinkOptions): {route: ComputedRef<RouteLocation & {href: string}>; href: ComputedRef<string>; isActive: ComputedRef<boolean>; isExactActive: ComputedRef<boolean>; navigate: (e?: MouseEvent) => Promise<void | NavigationFailure>}; NavigationFailureType: NavigationFailureType; LocationAsRelativeRaw: LocationAsRelativeRaw; RouteLocationOptions: RouteLocationOptions; createRouter(options: RouterOptions): Router; matchedRouteKey: InjectionKey<ComputedRef<RouteRecordNormalized | undefined>>; START_LOCATION: RouteLocationNormalizedLoaded; UseLinkOptions: UseLinkOptions; createRouterMatcher(routes: Readonly<RouteRecordRaw[]>, globalOptions: PathParserOptions): RouterMatcher; RouterMatcher: RouterMatcher; RouterViewProps: RouterViewProps}) {

}


export declare function compile(template: string | HTMLElement, options?: CompilerOptions): RenderFunction;


export * from "@vue/runtime-dom";

export { }
